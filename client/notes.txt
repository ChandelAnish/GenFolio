Why Convert a File to a Data URL (Base64)?
    1ï¸âƒ£ Direct Preview in the Browser
            - A file (like an image) is stored on the user's device, and browsers canâ€™t display raw files directly.
            - readAsDataURL(file) converts the image into a Base64 string, which can be directly assigned to an <img> tag.
    2ï¸âƒ£ No Need for a Temporary File Storage
            - Instead of uploading the file and getting a URL from the server, you generate a temporary URL using Base64.
            - This is useful for instant previews in forms before uploading.



****In Next.js App Router (app directory), API route handlers only receive req (not res).

****Whenever you return an object inside an arrow function without return, use () to enclose it.
        - In JavaScript, when using an arrow function without curly braces ({}), the function implicitly returns whatever comes after =>.
        - However, if you want to return an object, you need to wrap it in parentheses (()) because curly braces {} are interpreted as a function body, not an object.



***setProfileData((prev) => ({ ...prev, [name]: value }));
        -> the square brackets around [name] are necessary in this context. This is using JavaScript's computed property name syntax, and here's why it's needed:
        -> When you write [name]: value, you're using the variable name to dynamically determine which property of the object to update.



*In Tailwind CSS, the space-y-4 class is used to add vertical spacing between child elements inside a container.



*reduce function:

        The reduce function in JavaScript is used to take an array and reduce it to a single value. It works by applying a function to each element in the array, carrying forward a cumulative result.

        How It Works 
                - It goes through each item in the array.
                - It keeps adding (or processing) the items based on the given function.
                - It finally returns a single value.

        Syntax:
                array.reduce(callback, initialValue)
                        - callback: A function that runs on each element.
                        - initialValue: The starting value (optional but recommended)

        Example: Sum of Numbers

                const numbers = [1, 2, 3, 4, 5];
                const sum = numbers.reduce((accumulator, currentValue) => {
                return accumulator + currentValue;
                }, 0);
                console.log(sum); // Output: 15

                - accumulator starts at 0 (initial value).
                - currentValue goes through each number.
                - Adds each number to accumulator, resulting in 15.



*Record:
        - Record is a utility type in TypeScript.
        - It allows you to define the types for the keys and values of an object.

        eg: The Record<string, Skill[]> is a TypeScript type that defines an object where:
                - The keys are strings (string).
                - The values are arrays of Skill objects (Skill[]).



*flat() function:
        The flat() function in JavaScript is used to flatten an array, meaning it removes nested arrays and creates a single-level array.

        Example : 
                const arr = [1, 2, [3, 4], [5, 6]];
                const flatArr = arr.flat();
                console.log(flatArr); // Output: [1, 2, 3, 4, 5, 6]



*sessionStorage.getItem('profileData') can return null if the key does not exist in the storage. However, JSON.parse() expects a string as its argument, and null is not a valid input for it.

        Fix:
                Use the nullish coalescing (??) or logical OR (||) operator to provide a fallback value:

                        const a = JSON.parse(sessionStorage.getItem('profileData') ?? '{}');







***Making API Calls in a Next.js route.ts File
        -> Since route.ts files are server-side route handlers in Next.js App Router (app/api), you can make backend-to-backend API calls using libraries like fetch or axios.
        -> âœ… Works for: Calling external APIs (e.g., third-party APIs, internal microservices).
        -> âŒ Doesn't Work for: Calling the same API route from itself (causes infinite loop).
        -> If you want to call your own Next.js API route from another API route (route.ts), you should directly import the function instead of making an HTTP request.


***revalidatePath() --> is a Next.js function used in server actions to clear the cached data for a specific route and force a fresh data fetch. When you use revalidatePath('/tasks'), you're telling Next.js to:

        - Clear the cached data for the '/tasks' route
        - Trigger a fresh server-side render of that page
        - Ensure that any subsequent data fetches on that route will pull the most recent data from the database

        If you are using Next.js App Router (with React Server Components and caching), deleting a task and revalidating the path will not immediately update the UI unless you handle state updates properly. Hereâ€™s what happens:

        Static Data Fetching (getServerSideProps or fetch with caching)

                - If you fetch data with fetch('/api/tasks'), Next.js may cache the response.
                - When you delete a task, you must revalidate the cache using:
                        import { revalidatePath } from "next/cache";
                        revalidatePath("/tasks");
                - This ensures that when the user navigates, they get the updated data.
---------------

ğŸ§  What are Clerk session claims?
        Think of session claims as extra information you attach to a logged-in userâ€™s session.

ğŸ“¦ Example:
        Imagine you have a user logged in, and you want to remember:

                - If theyâ€™ve created their portfolio
                - Their user role (admin/user)
                - Their preferred theme (dark/light)

        You can store these facts as claims in their session.

ğŸ”‘ Real-life analogy:
        Itâ€™s like giving someone a visitor badge that says:

                âœ… Youâ€™re allowed in (logged in)
                ğŸ‘¤ Youâ€™re an admin
                ğŸ¨ You like dark mode

        These "badges" are claims stored in their session.

ğŸ” Where can you use them?
        You can read session claims:

                - In middleware (to redirect users)
                - In API routes (to check permissions)
                - In server components (to customize what they see)

âœ… Example in code:

        // Set a claim (like "hasPortfolio: true") for the current user
        await clerkClient.users.updateUserMetadata(userId, {
          publicMetadata: {
            hasPortfolio: true,
          },
        });
        
        Later, check this in middleware:

        const hasPortfolio = sessionClaims?.publicMetadata?.hasPortfolio;

ğŸ“ Types of Claims:
        Type	                Use for	                        Accessible by

        publicMetadata	        General user info	        Frontend + Backend
        privateMetadata	        Sensitive info	Backend         only
        unsafeMetadata	        Internal/debug use	        Backend only


Add a Session Claim in Clerk

        ğŸ”¹ 1. Import clerkClient
                        import { clerkClient } from "@clerk/nextjs/server"; // or "@clerk/backend" if using backend-only
        ğŸ”¹ 2. Update the userâ€™s metadata
                        For example, letâ€™s say you want to set a hasPortfolio flag for a user:

                        await clerkClient.users.updateUserMetadata(userId, {
                        publicMetadata: {
                        hasPortfolio: true,
                        },
                        });

**clerkClient from @clerk/nextjs/server â Not available / not exported, that's why you get a TypeScript error.
**clerkClient from @clerk/clerk-sdk-node â âœ… The correct one to use in API routes, server actions, and app/api functions.

1. @clerk/nextjs/server
        Designed for middleware and route handlers in Next.js apps.

        Exports things like:

                - auth() â€“ for getting session info
                - currentUser() â€“ gets current signed-in user
                - redirectToSignIn â€“ for handling redirects

        âŒ Does not export a full clerkClient, so using clerkClient.users... from this will throw:
        Property 'users' does not exist on type '() => Promise<ClerkClient>'

2. @clerk/clerk-sdk-node
        Meant for server-side Node.js code, including:

                - API routes (app/api/...)
                - Custom backend logic
                - Serverless functions

        âœ… Exports clerkClient, which gives you access to the full Clerk backend SDK:

        import { clerkClient } from "@clerk/clerk-sdk-node";

        await clerkClient.users.updateUserMetadata(userId, {
          publicMetadata: {
            hasPortfolio: true,
          },
        });

Get logged-in user's ID/session	                -->     @clerk/nextjs/server
Update or manage user info (like metadata)	-->     @clerk/clerk-sdk-node




ğŸ” What exactly are session claims in Clerk?
        In Clerk, session claims are bits of data (like userId, publicMetadata, etc.) that are embedded in the session token (JWT). They're read-only in middleware using auth().

        There are two main sources of claims:

        1) Standard claims like userId, email, roles, etc.
        2) Custom claims (e.g., hasPortfolio: true) that you put into:

                 - publicMetadata
                 - privateMetadata
                 - sessionClaims (if using updateSession)

        ğŸ” Persistence rules:
                Claim Type	Persistence Scope	           Survives Logout?	        Editable?	Usage in Middleware

                - publicMetadata	Stored in user object	        âœ… Yes	                âœ… Yes	        âœ… Yes
                - privateMetadata	Stored in user object	        âœ… Yes	                âœ… Yes	        âŒ No (middleware can't access)
                - sessionClaims	        Stored in the session JWT	âŒ No	                âœ… Yes	        âœ… Yes

        So:
                - publicMetadata is best if you want persistent state (like hasPortfolio) available even after logout.
                - sessionClaims are useful for temporary per-session custom data (e.g., a flag during a checkout flow).


âœ… publicMetadata.hasPortfolio will persist:
        Yes, anything stored in publicMetadata (like hasPortfolio: true) will remain attached to the userâ€™s account permanently â€” until you explicitly change or remove it using:

        await clerkClient.users.updateUserMetadata(userId, {
          publicMetadata: {
            hasPortfolio: false, // or remove this key
          },
        });

ğŸ” When will it disappear?
        âŒ It does NOT expire automatically.
        âŒ It is NOT cleared when the user logs out or their session expires.
        âœ… It stays stored in Clerkâ€™s backend tied to that userâ€™s account.

        So unless you or your code removes/updates that metadata, it will always exist.

â± If you want temporary flagsâ€¦
        If you ever need a temporary state that expires with the session, then you should use sessionClaims instead â€” they are tied to the session token and disappear when the session ends.

Summary:
        Type	        Persists after logout?	        Expires automatically?	        Where stored?

        publicMetadata	âœ… Yes	                                âŒ No	                Clerk user object
        sessionClaims	âŒ No	                                âœ… Yes (with session)	JWT session token



âœ… What is publicMetadata?
        - Itâ€™s stored data attached to the user in Clerk.
        - You can think of it like a "profile extension" â€” data you can set yourself, like:
        - It lives on the user object in Clerk.

âœ… What is sessionClaims?
        - It's a snapshot of key data about the user at the time they logged in, including:
        - Their userId
        - Their email
        - Any metadata Clerk puts there (like roles, permissions)
        - And optionally: publicMetadata, privateMetadata, etc.

â“Why is publicMetadata inside sessionClaims?
        Because when the session is created (i.e., the user signs in), Clerk includes a copy of the userâ€™s publicMetadata in the sessionClaims.

        This lets you quickly access data without hitting Clerkâ€™s API â€” but it's a static snapshot, not live.

ğŸ” Problem
When you update publicMetadata later (e.g. after user builds portfolio), the sessionClaims:

        - Don't update automatically
        - Still show the old values (unless the session is refreshed)


âœ… Best Solution: Fetch publicMetadata manually in middleware instead of relying on sessionClaims
        Since sessionClaims won't immediately reflect the updated metadata, the safest and smoothest approach is to fetch the full user object using clerkClient.users.getUser(userId) in your middleware.

âœ¨ Here's how you can do it:

        import { clerkClient } from '@clerk/clerk-sdk-node'

        export default clerkMiddleware(async (auth, req) => {

                // Instead of relying on sessionClaims
                const user = await clerkClient.users.getUser(userId);
                const hasPortfolio = user.publicMetadata?.hasPortfolio;

        });

        âœ… Why this works better:
                âœ… No need to sign out/in
                âœ… Gets the latest publicMetadata instantly
                âœ… User experience is smooth â€” they can generate their portfolio and be redirected without interruption


----------------------------

ğŸ¯ What is a "Direct File Request"?
âœ… Example 1 â€” What you did:
You pasted an S3 link in the browser like this: https://my-bucket.s3.amazonaws.com/image.jpg
This is just like telling your browser: "Hey, go to this URL and show me the file."

The browser:

Sends a normal HTTP request
Just renders what it receives (image, PDF, etc.)
Doesnâ€™t care about CORS
Youâ€™re not trying to access it with JavaScript

âœ… It works fine. Always.

ğŸ¯ What is a "Cross-Origin Request"?
âŒ Example 2 â€” What you tried programmatically: fetch("https://my-bucket.s3.amazonaws.com/image.jpg")
Now you are saying: "Hey browser, from my JavaScript code running on localhost:3000, I want to read the contents of a file on s3.amazonaws.com."

This is now a cross-origin request (from localhost:3000 â†’ s3.amazonaws.com), and it must follow CORS rules.

The browser checks:

â“ "Did S3 give me permission to let this JavaScript access its contents?"
If not â†’ âŒ CORS error

ğŸ§  So What's the Key Difference?
Action	                                                                CORS required?	        Why?
ğŸ§â€â™‚ï¸ You type/paste URL in browser	                                   âŒ No	                 Youâ€™re just viewing it, not using JS
ğŸ¤– Your JavaScript uses fetch() or loads image into canvas or jsPDF	âœ… Yes	              JS is trying to read or process the content

ğŸ¨ Real-World Analogy

Imagine a library ğŸ“š:

You (the user) can walk in and look at any book freely.
But if you send your robot assistant (JavaScript) to go in and copy the content, the library will say:
â€œWait! Your robot must have permission!â€
That permission is called CORS headers.

âœ… Conclusion (in one sentence)
If you're using JavaScript to read, fetch, or process something from another domain (like S3), CORS rules apply â€” but if you're just viewing it (like typing the link), they donâ€™t.








**The browser does make an HTTP request even when you type/paste a URL

You're right: When you paste https://your-bucket.s3.amazonaws.com/image.jpg in the address barâ€¦

ğŸ‘‰ The browser makes a GET request to S3 to download the image.

ğŸ§  So Why Is CORS Not Applied Here?
Because: CORS is a security policy that applies only to JavaScript running in the browser trying to access resources from a different origin.

ğŸ” Letâ€™s go deeper with an example

ğŸ”¹ Example 1: Typing URL in address bar:

        You paste this in browser: https://my-bucket.s3.amazonaws.com/image.jpg
        This is treated like a normal file download or navigation request.

        ğŸ§  The browser is just saying: "Fetch this image and display it directly."

        âœ… No JavaScript involved
        âœ… No attempt to read content using JS
        âœ… No DOM access
        â¡ï¸ So, CORS does not apply


ğŸ”¹ Example 2: JavaScript tries to fetch the image
const res = await fetch("https://my-bucket.s3.amazonaws.com/image.jpg");
Now the browser is saying: "Wait a minute... JavaScript from localhost:3000 is trying to access data from s3.amazonaws.com. Is that allowed?"

ğŸ’¥ Now it becomes a cross-origin request
â¡ï¸ CORS headers must be present, otherwise: Access to fetch at 'https://...' from origin 'http://localhost:3000' has been blocked by CORS policy...

ğŸš¦ Simple Rule of Thumb
How the request is made	        Does CORS apply?	 Why?
Typing URL in browser	        âŒ No	                No JS is reading the response
<img src="url" />	        âŒ No                    (unless canvas is used)	Image is rendered, not read by JS
fetch('url') in JS	        âœ… Yes	                JS is reading cross-origin content
canvas.drawImage(img)	        âœ… Yes                   (if img is cross-origin)	Reading or exporting pixels requires permission
jsPDF.addImage('url')	        âœ… Yes	                JS reads image to embed into PDF

**ğŸ” CORS is NOT about permission to view
        CORS is NOT meant to protect the file from being viewed. Anyone with the link can see it.
        ğŸ‘‰ CORS is about controlling what JavaScript from another domain is allowed to do with that resource.








ğŸ¤” When you type a URL in the browser address bar (e.g. an image or PDF file): https://your-bucket.s3.amazonaws.com/image.jpg
        â“ Who makes the HTTP request?
        ğŸ‘‰ The browser itself makes the HTTP request â€” but not via JavaScript.

âœ… So whatâ€™s actually happening?
        You hit Enter after typing the URL.
        The browser initiates a navigation request.
        This is just like saying: â€œDear browser, go to this URL and show me whatever comes back.â€

ğŸ’¡ It works exactly like loading a new page. No scripts run â€” just a basic HTTP GET request by the browser.

ğŸ§  Important Distinction
Action	                                Who sends the request	Is JS involved?	                                Does CORS apply?
Typing a URL (e.g., image, PDF)	        Browser (network layer)	âŒ No	                                        âŒ No
Clicking an <a href="..."> link	        Browser	                âŒ No	                                        âŒ No
Setting <img src="...">	                Browser	                âŒ (JS can assign src, but not read content)	âŒ No (unless accessing it via JS)
Calling fetch() / XMLHttpRequest in JS	JavaScript	        âœ… Yes	                                        âœ… Yes

ğŸ” Real-world analogy
        ğŸ‘¨â€ğŸ’» Typing a URL:
                Like opening a file in your browser.
                ğŸŸ¢ Anyone can view it
                âŒ You're not trying to look inside it with a tool
                So â€” CORS is not triggered

ğŸ¤– JavaScript trying to fetch a file: Like sending a robot to fetch and scan the fileâ€™s contents

        ğŸ›‘ Now security rules (CORS) apply because:
        The robot (JavaScript) could leak data or manipulate it
        So the server must explicitly allow access via Access-Control-Allow-Origin headers





****so when browser makes a HTTP request it just gets the content and directly renders it but when js makes a HTTP call it tries to read and scan the content which need CORS permissions.


âœ… When browser makes an HTTP request (like typing a URL or <img src="...">):
It just downloads the content.

It renders it directly (image, PDF, video, etc.).
It does not try to read, parse, or inspect the content using JavaScript.
So: CORS is not applied.

ğŸ“¦ Think of it like: "Get this file, and just display it to the user."

âŒ When JavaScript makes an HTTP request (like fetch() or axios.get()):
The JS code reads the content â€” to:

Parse it
Access data
Use it in canvas, jsPDF, etc.

So the browser enforces CORS policy to protect users and servers from data leaks.

ğŸ” Think of it like: "A script from another website is trying to open and read private data â€” should we allow this?"

----------------------


â“ Which line downloads the PDF.js library?
This line sets the URL of the PDF.js library to be downloaded:

script.src = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js';
But this only defines the source, it does not start downloading yet.

ğŸš€ The actual download happens here:

document.head.appendChild(script);
ğŸ” Why?
Because JavaScript on the web only starts loading a <script> when it's added to the DOM (the HTML structure of the page).
This line puts the <script> inside the <head> tag of your HTML.

ğŸ¯ So what happens exactly?
âœ… document.createElement('script') â€” creates a new <script> tag.
âœ… script.src = ... â€” tells it what file to download (PDF.js from CDN).
âœ… document.head.appendChild(script) â€” adds that <script> to the page.
âœ… Browser sees it, downloads the file, and runs it.
âœ… Once the script is downloaded and run, it adds pdfjsLib to window.

ğŸ¤” Where is the downloaded library stored?
Once PDF.js is loaded, itâ€™s available globally at:

window.pdfjsLib
This means you can access it from anywhere in your frontend code â€” it's stored in memory by the browser as a global variable.








ğŸªŸ What is window?
window is a global object provided by the browser in every web page.

You can think of it as: The main container for everything related to your web page and browser environment.

It holds:

- the DOM (document)
- functions like alert(), setTimeout()
- data like screen size, location, cookies
- and anything you attach to it (like window.pdfjsLib)

ğŸ” Example

console.log(window);
This will log a huge object in the browser console â€” full of useful stuff.

Some common things inside window:


window.alert        // The alert function
window.document     // The entire HTML document
window.location     // Info about the current URL
window.innerWidth   // Width of browser window

ğŸ”§ Why use window.pdfjsLib?
When we load an external library like PDF.js, it adds itself to the global window object:

window.pdfjsLib - So now we can use it anywhere in our app after it's loaded.

âœ… Simple analogy
Think of window like your browser's backpack ğŸ’.

Inside it:

document = your notebook ğŸ““ (HTML)
alert, setTimeout, etc. = tools ğŸ”§
pdfjsLib = something you put in after loading a script ğŸ“„

ğŸ‘€ Bonus Tip
In browser JavaScript:

window.alert('Hi!')
// is the same as
alert('Hi!')
Because window is the default global object, so you donâ€™t always need to write window.







ğŸ§± Line of code:

window.pdfjsLib.GlobalWorkerOptions.workerSrc = 
  'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';
ğŸ” What is happening here?
We are telling PDF.js: â€œHere is the location (URL) of your helper file that you need to read PDF files.â€

ğŸ“¦ What is pdf.worker.min.js?
It is a worker file.
Think of it as a background helper that PDF.js uses to do heavy work (like parsing and rendering PDFs) without freezing the page.

ğŸ› ï¸ What is GlobalWorkerOptions.workerSrc?
It is a setting in PDF.js where you tell it:

"When you want to use your worker, load it from this link."

ğŸ§  Why do we need to set it?
If you donâ€™t set this line, PDF.js will throw an error like: âŒ â€œThe workerSrc property must be set.â€
Because it doesnâ€™t know where to find its helper file.

âœ… Simple English Explanation
â€œHey PDF.js, when you need help reading a PDF, go to this link and get your helper file.â€

ğŸ§  Analogy
Imagine:

PDF.js is a chef ğŸ‘¨â€ğŸ³
The chef has a helper (worker) ğŸ‘¨â€ğŸ³ who lives in another house.
Before cooking, you must give the chef the address of the helper:







â“ Does this line actually download the worker file?

window.pdfjsLib.GlobalWorkerOptions.workerSrc = 
  'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';
ğŸ‘‰ NO, this line does not download anything immediately.

ğŸ“¦ What it really does:
This line simply tells PDF.js: â€œWhen you need your background helper (worker), go to this URL and download it.â€

ğŸ’¡ So when is it downloaded?
The file at 'pdf.worker.min.js' is only downloaded when PDF.js starts doing some actual PDF work, like:

Reading pages
Extracting text
Rendering pages

That's when PDF.js says: â€œOkay, now I need my helper... let me go download it from the URL you gave me.â€


ğŸ” So the flow is:

ğŸ”— Set the URL to the helper file (with workerSrc)
ğŸ’¤ Nothing happens yet
ğŸ§¾ You try to extract or render a PDF
ğŸƒâ€â™‚ï¸ PDF.js downloads and runs the worker file

ğŸ§  Conclusion
This line sets the path â€” it does NOT download.
The file is downloaded later, automatically by PDF.js, when itâ€™s needed.








await pdfjsLib.getDocument({ data: arrayBuffer })
This tells PDF.js: â€œHere's the PDF file's raw data â€” I want you to start loading this document.â€

PDF.js begins to read and load the PDF file in the background.
Butâ€¦ loading takes time.



.promise
pdfjsLib.getDocument(...)
This doesn't return a Promise directly.

It returns a PDF loading task object, like this:
{
  promise: Promise<PDFDocument>,
  destroy: Function,
  onProgress: Function,
  ...
}
So to get the actual PDFDocument, you have to access .promise inside it.



So:
pdfjsLib.getDocument({ data: arrayBuffer }).promise
means: â€œStart loading the PDF, and let me know when you're done.â€









const textContent = await page.getTextContent();

ğŸ§  What it means in one line:
â€œGet all the words (text pieces) from this page of the PDF.â€

ğŸ” Breakdown:
âœ… page
This is one page of the PDF (you got it using await pdf.getPage(pageNum)).

âœ… getTextContent()
This is a function provided by PDF.js that:

Pulls out all the visible text on the page.
But it gives you the text in small parts â€” not one big string.
Each part looks like this:


{ str: "Hello", ... }
{ str: "world", ... }
So you need to join them later (which you already do in your code).

await page.getTextContent() return:
{
  items: [
    {
      str: "Hello",             // The actual text
      dir: "ltr",               // Text direction (left-to-right)
      width: 42.56,             // Width of the text block
      height: 12.8,             // Height of the text block
      transform: [1, 0, 0, 1, 100, 700], // Positioning on page
      fontName: "g_d0_f1"       // Internal font name
    },
    {
      str: "world",
      ...
    },
    ...
  ],
  styles: {
    "g_d0_f1": {
      fontFamily: "Arial",
      ascent: 0.9,
      descent: -0.2,
      fontWeight: "normal"
    }
  }
}

It returns an object with:
        items: An array of small text chunks (like individual words or lines).
        styles: Extra info about the fonts used for those chunks.

âœ… await
Because this process takes time (PDF reading is slow), we add await to: Wait for the text to finish loading before moving on.

âœ… Full Meaning

const textContent = await page.getTextContent();
means: â€œAsk PDF.js to give me all the small pieces of text from this page, and wait until it's done.â€

ğŸ“¦ Example of textContent.items
After running that line, youâ€™ll get something like:

{
  items: [
    { str: "Hello" },
    { str: "world" },
    { str: "from" },
    { str: "page" },
    { str: "1" }
  ]
}
You then combine those using .map(...).join(" ") in the next line to form: "Hello world from page 1"












âœ… What is getAnnotations()?
ğŸ“Œ In simple terms:
getAnnotations() gets all the extra interactive elements (called annotations) on a PDF page â€” like links, buttons, form fields, etc.
getAnnotations() is a method provided by PDF.js.

ğŸ§  Think of a PDF page like a picture:
        - The text is what you see and read
        - The annotations are interactive stuff on top of the page, like:
                Hyperlinks
                Clickable buttons
                Checkboxes
                Signatures
                etc.

ğŸ“¦ Example:
If a page says:

"Visit Google"
And you can click on the word "Google" â€” thatâ€™s a Link annotation.

âœ… What does getAnnotations() return?
It returns an array of objects like this:

[
  {
    subtype: "Link",
    url: "https://google.com",
    ...
  },
  {
    subtype: "Widget",
    fieldType: "Btn",
    ...
  }
]

âœ… What is subtype?
ğŸ·ï¸ subtype is a label that tells you what kind of annotation it is.
Some common subtype values:

subtype	        Meaning
"Link"	        A clickable hyperlink
"Widget"	A form field (button, input box)
"Text"	        A popup text note
"Highlight"	A highlight over some text


In your code, youâ€™re only interested in this:

if (annotation.subtype === "Link")
That means:

"If this annotation is a clickable link, process it."

ğŸ§  Summary:
Term	                Meaning
getAnnotations()	Returns all the interactive items on a PDF page
subtype	                Tells you what kind of interactive item it is (like "Link" for a hyperlink)





Not all PDFs define links the same way. There are 2 common ways to define a clickable link:

1. Direct URL link
        {
          subtype: "Link",
          url: "https://example.com"
        }
        This is the simple and common way.

2. Action-based URL link
        {
          subtype: "Link",
          action: {
            type: "URI",
            url: "https://example.com"
          }
        }









âœ… What is .match() in JavaScript?
ğŸ“Œ Answer: match() is a built-in JavaScript string method.

âœ… Syntax:
        const matches = string.match(regex);
        string is any text you want to search in.

regex is the pattern you want to find (a regular expression).

ğŸ§  What does it return?
Case	                        What it returns
If the pattern is found	        â†’ An array of all matches (if using /g)
If nothing is found	        â†’ null



âœ… 1. String.prototype.replace()
ğŸ”§ What it does:
Replaces parts of a string with something else.

âœ… Syntax:
string.replace(searchPattern, replacement)
Parameter	Meaning
searchPattern	What to find (can be a string or a regex)
replacement	What to put instead

âœ… Returns:
A new string with replacements made.
(It does not change the original string.)

ğŸ§  Example:
"123-456".replace("-", "")  // "123456"
"987 654 3210".replace(/[\s\-]/g, "")  // "9876543210"

Explanation:
/[\s\-]/g = match all spaces and dashes
"" = replace with nothing (i.e., remove them)




âœ… 2. RegExp.prototype.test()
ğŸ” What it does:
Checks if a pattern (regex) exists in a string.

âœ… Syntax:

pattern.test(string)
Parameter	Meaning
pattern	        A regular expression (e.g. /\d{7,}/)
string	        The string to test the pattern on

âœ… Returns:
true if the pattern is found, false if not.

ğŸ§  Example:

/\d{7,}/.test("1234567")   // true âœ… (has 7 digits)
/\d{7,}/.test("12345")     // false âŒ (only 5 digits)

âœ… Summary
Method	        Purpose	Takes	                                        Returns
replace	        Change part of a string	(pattern, replacement)	        New string
test	        Check if a pattern is found	(string)	        true / false














----------------------------

An <iframe> (short for inline frame) is an HTML element that lets you embed another webpage inside your current webpageâ€”like a window showing content from another website.

ğŸ” In simple words:
An iframe is like putting a mini browser inside your page.
You can use it to show things like:

YouTube videos ğŸ¥
Google Maps ğŸ—ºï¸
Another website ğŸŒ
PDF files ğŸ“„

ğŸ“¦ Example:

<iframe
  src="https://www.youtube.com/embed/dQw4w9WgXcQ"
  width="560"
  height="315"
  allowfullscreen
></iframe>
âœ… This shows a YouTube video player right inside your website.

ğŸ›  Common uses:

Embedding YouTube videos
Embedding Google Forms or Maps
Showing external tools or dashboards
Displaying a PDF or another webpage

âš ï¸ Note:
Iframes load external content, so they may be blocked if the other site doesnâ€™t allow embedding.
You donâ€™t control the content inside the iframeâ€”itâ€™s like viewing another website.

ğŸ” Security Tip:
Iframes can introduce security risks (e.g., clickjacking), so: Only embed trusted content
Use attributes like sandbox, allow, and referrerpolicy to control behavior

ğŸ§  Analogy:
Imagine your webpage is a house, and the iframe is like a TV on the wall that plays content from another channel (website). You can see it, but itâ€™s coming from outside.








ğŸ”¹ What is embedding?
Embedding means inserting content from one source into another.
In websites, it usually means showing content from another website inside your ownâ€”without copying it.

âœ… Example:
Letâ€™s say you want to show a YouTube video on your webpage.

You could embed it like this:

<iframe src="https://www.youtube.com/embed/dQw4w9WgXcQ"></iframe>
This shows the video from YouTube, but inside your own site.

ğŸ“Œ So in simple terms:
Term	        Meaning
Embedding	Showing content from another site inside yours (like videos, maps, tweets, etc.)
Iframe	        The HTML tool used to do the embedding

ğŸ”’ Why sites might block embedding:
Some websites donâ€™t allow others to embed their content for:

Security reasons
Privacy protection
Brand control (they want people to visit their site directly)

They block it by setting HTTP headers like:
                X-Frame-Options: DENY
                Content-Security-Policy: frame-ancestors 'none';

ğŸ§  Analogy:
Imagine embedding is like showing a live feed from another TV channel in your room. If that channel doesnâ€™t give you permission, the screen stays black.








To help improve security, privacy, and behavior control when you're embedding external content use :

ğŸ” 1. sandbox
The sandbox attribute applies extra restrictions to the embedded content.

âœ³ï¸ By default:
When you add sandbox, the iframe loses many permissions â€” it canâ€™t:

        - Run JavaScript
        - Submit forms
        - Open new windows/tabs
        - Access your cookies or local storage


âœ… Example:

<iframe src="..." sandbox></iframe>
This fully locks down the iframe.

You can give back specific permissions like this:

<iframe src="..." sandbox="allow-scripts allow-forms"></iframe>
ğŸ”“ Common options:

Value	                What it allows
allow-scripts	        Run JavaScript
allow-forms	        Submit forms
allow-same-origin	Be treated as same-origin (for cookies, etc.)
allow-popups	        Open new windows/tabs



âœ… 2. allow
This attribute lets you allow specific features in the iframe (like camera access, autoplay, fullscreen, etc.).

âœ… Example:

<iframe
  src="https://www.youtube.com/embed/xyz"
  allow="autoplay; fullscreen"
></iframe>

ğŸ§© Common feature values:

Value	                What it allows
autoplay	        Automatically play audio/video
fullscreen	        Enter fullscreen mode
camera / microphone	Use camera/mic
clipboard-write	        Access clipboard
encrypted-media	        Play DRM-protected media
geolocation	        Use GPS location


DRM protected content refers to digital media, such as videos, music, ebooks, or software, that has been encrypted and secured using Digital Rights Management (DRM) technology. This prevents unauthorized access, copying, distribution, and other actions that would violate the content owner's rights. Essentially, DRM ensures that only authorized users can access and use the content, according to the permissions granted by the content creator or distributor. 



ğŸ›¡ 3. referrerpolicy
This controls what referrer information (i.e., the URL of your page) is sent to the iframeâ€™s source.

âœ… Example:

<iframe
  src="https://example.com"
  referrerpolicy="no-referrer"
></iframe>

ğŸ§© Common values:

Value	                                What it does
no-referrer	                        Sends no referrer at all
origin	                                Sends just the domain (https://yoursite.com)
strict-origin-when-cross-origin	        Sends full URL to same origin, only domain to others
unsafe-url	                        Sends full URL always (âš  not recommended)


ğŸ§  Summary Table
Attribute	        Purpose
sandbox	                Restrict iframe capabilities (security)
allow	                Enable specific browser features
referrerpolicy	        Control what referrer is shared







ğŸ” What is a referrer?
A referrer (also called HTTP referrer) is the URL of the webpage that a user came from before landing on another page.

âœ… Example:
Letâ€™s say:

Youâ€™re on https://yourwebsite.com/page1
You click a link that takes you to https://example.com
When your browser opens example.com, it sends this in the request headers:

Referer: https://yourwebsite.com/page1
âœ… This tells example.com: "Hey, the user came from yourwebsite.com/page1"

ğŸ” Why referrer is useful:
                Analytics: see where users are coming from
                Security: detect suspicious traffic
                Marketing: track click sources (e.g., from email, ad, or social media)

âš ï¸ Why you might want to control the referrer (using referrerpolicy):
Because it can reveal:

        - Your page URL
        - Your query params
        - Sensitive paths (/private, /checkout?userId=123)
        - You might not want to leak that info when embedding an iframe or opening links.

âœ… Example using referrerpolicy:

<iframe
  src="https://external-site.com"
  referrerpolicy="no-referrer"
/>
This makes sure no referrer is sent to external-site.com.

ğŸ§  Summary:
Term	Meaning
Referrer	        The URL of the page that the user came from
Sent by	                Your browser, automatically (unless blocked)
Can be controlled by	The referrerpolicy attribute or HTTP headers






ğŸ¥ What is a YouTube Video ID?
A Video ID is a unique 11-character code that identifies a specific video on YouTube.

ğŸ§  Example:
In this YouTube link: https://www.youtube.com/watch?v=dQw4w9WgXcQ
The Video ID is: dQw4w9WgXcQ

Itâ€™s like the fingerprint or ID number for that video. No two videos share the same ID.

â“ Why do we need the Video ID?
YouTube uses the Video ID to: Find and play the correct video
Embed videos inside a website (like youâ€™re doing in your app)

ğŸ”— When embedding a video on a website:
You donâ€™t embed the whole YouTube URL â€” you just use the Video ID inside a special embed link: https://www.youtube.com/embed/{VIDEO_ID}

For example: https://www.youtube.com/embed/dQw4w9WgXcQ
This lets your website show the video inside an <iframe>.

âœ… In short:
Term	Meaning
Video ID	A unique 11-character code (e.g. dQw4w9WgXcQ)
Why needed	Used to embed or play the correct video on your site
How it's used	Inserted into an embed URL like https://www.youtube.com/embed/ID






ğŸ”— What is an Embed Link?
An embed link is a special URL that lets you show a YouTube video directly inside your website using an <iframe>.

It looks like this: https://www.youtube.com/embed/dQw4w9WgXcQ

This is different from a normal YouTube link like: https://www.youtube.com/watch?v=dQw4w9WgXcQ

â“Why canâ€™t I use the normal YouTube link in an <iframe>?
Here's why not:

ğŸ” Feature	                Normal Link (watch?v=...)	Embed Link (/embed/...)
Designed for website embedding	âŒ No	                                âœ… Yes
Works inside <iframe>	        âŒ Often blocked or wonâ€™t autoplay	âœ… Works perfectly in iframes
Clean fullscreen experience	âŒ Shows extra UI (comments, etc.)	âœ… Just the video player
Customization (autoplay, etc)	âŒ Limited                               âœ… You can add params like autoplay=1


âœ… Use embed link when:

        - You want to show the video directly inside your app/page
        - You want autoplay, fullscreen, or to hide related videos
        - Youâ€™re using an <iframe> (like your component does)


ğŸ§ª What happens if you try the normal link?
If you write:

<iframe src="https://www.youtube.com/watch?v=dQw4w9WgXcQ"></iframe>
It will either: Not show the video properly, or Open the full YouTube site inside the frame, which is not allowed or bad UX

âœ… Correct usage:

<iframe 
  src="https://www.youtube.com/embed/dQw4w9WgXcQ" 
  allowfullscreen 
></iframe>
Works smoothly, looks clean, and is meant for embedding.






ğŸ§© What does component="iframe" do in this?

<Box component="iframe" ... />
ğŸ‘‰ Normally:
<Box> is a MUI (Material UI) component. By default, it renders as a <div>.

ğŸ‘‰ But with component="iframe":
You're telling the MUI <Box> to render as an <iframe> instead of a <div>.

âœ… So this:
<Box component="iframe" src="..." />
is the same as writing:
        <iframe src="..." />
        ...but with MUI styling support (like sx={{ width: "100%" }} etc.)

ğŸ¯ Why use it?
You get:

The power of MUI (like sx styling)
But it still behaves like a regular <iframe>
So: Looks like Box, acts like iframe ğŸ‘Œ




ğŸ” What does this do?
allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture"
This is an iframe permission string. It tells the browser what the iframe is allowed to do.

Letâ€™s break them down:

Permission	        What it allows
accelerometer	        Lets the video respond to motion sensors (mostly for mobile/VR)
autoplay	        Allows the video to start playing without clicking
clipboard-write	        Lets the iframe copy data to the user's clipboard
encrypted-media	        Allows playback of protected content (like DRM videos)
gyroscope	        Lets the video react to device orientation (used in VR/360 videos)
picture-in-picture	Allows users to pop out the video and keep watching while multitasking


Picture-in-Picture(PiP) lets the video pop out into a small floating window so you can keep watching while doing something else on your screen.

ğŸ” Example:
You're watching a YouTube video â†’ you tap the PiP button â†’ The video shrinks into a small box in the corner of your screen â†’ You can now browse other tabs or apps, and the video keeps playing.


--------

1) | in regex means "OR"
2) ^ Means: start of the string
        It tells the regex: "Start matching from the very beginning of the text."
3) .*
        . means: any character (except newline)
        * means: zero or more times

        So .* means: â€œMatch anything, for as long as you want.â€

4) \w in regex means: Match any word character

        ğŸ” What is a "word character"?
        It includes:

                - All letters: aâ€“z, Aâ€“Z
                - All digits: 0â€“9
                - The underscore: _

        So: \w  =  [a-zA-Z0-9_]


        Regex	Meaning
        \w	One word character (a-z, A-Z, 0-9, _)
        \w+	One or more word characters
        \w*	Zero or more word characters

----------



â“ What's the problem without asChild?
If you donâ€™t use asChild, TooltipTrigger wraps your element like this:

<TooltipTrigger>
  <button>Click me</button>
</TooltipTrigger>

This becomes:
        <span>       â† Added by TooltipTrigger
                <button>Click me</button>
        </span>
Now your button is inside a span, and:

button styles like hover, focus, outline, etc. may not work correctly.
If you're using flex, grid, or tooltips on icons, this can break layout or cause bugs.

âœ… What asChild does
When you write:

<TooltipTrigger asChild>
  <button>Click me</button>
</TooltipTrigger>


It renders: <button>Click me</button>
ğŸ‘‰ No extra element â€” the button becomes the trigger directly.

ğŸ’¡ So in short:
Without asChild	                        With asChild âœ…
Adds a span around your element	        Uses your element directly
Can break styles or layout	        Keeps your layout clean
Not ideal for buttons/icons	        Perfect for interactive elements



**asChild tells TooltipTrigger: â€œDonâ€™t create your own element â€” just use my child (like a button or icon) directly.â€


â“ What happens to styles and other properties passed to <TooltipTrigger> when you use asChild?
âœ… Answer:
When you use asChild, the props passed to TooltipTrigger are forwarded to its child â€” but only if the child supports receiving them.

âœ… Example:

<TooltipTrigger asChild className="bg-red-500 p-2">
  <button className="text-white">Click me</button>
</TooltipTrigger>
In this case:

The className="bg-red-500 p-2" from TooltipTrigger will be merged with the child's <button> element.
Resulting classes applied to <button> will be: bg-red-500 p-2 text-white

âœ… So yes â€” styles and event handlers (like onClick, onFocus, etc.) from TooltipTrigger are applied to the child.

ğŸ§  How does it work?
This is possible because asChild uses a utility called <Slot /> from Radix UI, which:

Takes all the props passed to TooltipTrigger (like className, style, onClick, etc.)
Applies them to the child (like <button>, <div>, etc.)
Merges className values

âš ï¸ Important Notes:
If the child already has className, style, etc., both will be merged, not overwritten.
If the child canâ€™t accept props (like a plain string), youâ€™ll get an error â€” so the child must be a React element (like button, div, span, etc.).
This only works because Radixâ€™s Slot system forwards those props for you. Itâ€™s not the same as Reactâ€™s {children}.

-------------



The /i in a regular expression means "case-insensitive" matching.

Example:

const regex = /hello/i;
        console.log(regex.test("Hello")); // true
        console.log(regex.test("HELLO")); // true
        console.log(regex.test("HeLLo")); // true

Without /i:

const regex = /hello/;
        console.log(regex.test("Hello")); // false


Summary:
/i is a flag -> It tells the regex engine to ignore case when matching letters (A vs a, B vs b, etc.).

Other common flags:

/g â€“ global match (find all matches, not just the first)
/m â€“ multiline mode (changes how ^ and $ behave)
/s â€“ dotAll mode (dot . matches newline too)