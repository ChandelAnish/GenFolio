tailwind class :
    rounded-tr-full: This class applies a fully rounded border-radius to the top-right corner of the element.
    rounded-bl-full: This class applies a fully rounded border-radius to the bottom-left corner of the element.
    rounded-br-full: This class applies a fully rounded border-radius to the bottom-right corner of the element.

    inset-0: Sets all four inset properties (top, right, bottom, left) to 0, making the element fill its containing block.
    bg-gradient-to-br: Applies a background gradient that starts from the top-left corner and ends at the bottom-right corner.
    from-purple-500/20: Sets the starting color of the gradient to a semi-transparent purple (purple-500 with 20% opacity).
    to-transparent: Sets the ending color of the gradient to transparent.
    pointer-events-none: Disables mouse interactions with the element.


What is getBoundingClientRect()?
    getBoundingClientRect() is a built-in JavaScript method that gives us the size and position of an element relative to the viewport (the visible part of the screen).

    Think of it as a way to measure how big an element is and where it is located on the screen.

    -> What is top?
        top is a property from getBoundingClientRect() that tells us the distance from the top of the viewport (screen) to the top of the element.

        -> If top is positive, the element is below the top of the screen.
        -> If top is negative, the element is partially scrolled out of view (above the screen). i.e The element is now partially above the viewport.
        -> If top is 0, the element is exactly at the top of the viewport.

    -> What is height?
        height is another property from getBoundingClientRect() that tells us how tall the element is (in pixels).

        It does not change when scrolling. It just represents the element's total height.

What is window.innerHeight?
    window.innerHeight is a built-in JavaScript property that returns the height of the visible area (viewport) of the browser window in pixels.


***When an element has absolute positioning, it is removed from the normal document flow.
        - This means the parent‚Äôs flexbox rules (like flex-col) don‚Äôt apply to them.
        - Instead, their position is controlled by top, left, right, and bottom values.




For Gradient Text :
    1. bg-clip-text (Background Clipping)
        - The bg-clip-text class ensures that the background only applies to the text itself rather than the entire element.
        - Normally, a background gradient is applied to the whole element, but this class clips it to the shape of the text.
        - Use the bg-clip-text utility to crop an element's background to match the shape of the text.
    2. text-transparent (Transparent Text)
        - The text-transparent class makes the actual text color fully transparent, so the underlying gradient background is visible instead.
        - Without this, the default text color would cover the gradient.


**const ExperienceCard: React.FC<ExperienceCardProps> = ({ company, role, duration, description, highlights, icon, index })=>{...}
        React.FC<ExperienceCardProps> - This tells React that:
                -This is a "Function Component" (FC)
                - It accepts props that must match the structure defined in ExperienceCardProps (which is an interface defined earlier in the code)



*      <motion.div
        className="p-6 bg-gradient-to-br from-cyan-900 to-slate-900 rounded-xl shadow-lg text-white max-w-2xl"
        initial={{ opacity: 0, x: 50 }}
        whileInView={{ opacity: 1, x: 0 }}
        transition={{ duration: 0.6, delay: index * 0.2 }}
        viewport={{ once: true }}
      />

      -> The viewport property allows you to define how and when an animation should run when the element enters the visible area of the screen.
            - once: true ‚Üí Ensures the animation only runs once when the element first enters the viewport.
            - once: false (default) ‚Üí The animation will run every time the element enters the viewport.


        *Trigger Animation Sooner (Custom Threshold)
                viewport={{ amount: 0.5 }} 
                    - amount: 0.5 ‚Üí Triggers when 50% of the element is in the viewport.
                    - Default is 0.25 (25% of the element visible).
        *Detect Only When Fully Visible
            viewport={{ amount: 1 }}
                - Triggers only when the entire element is visible in the viewport.



**The offset property in 'useScroll' defines when the scroll tracking starts and ends relative to the viewport and the target element.

        - "start start" -> The top of the target element (start) aligns with the top of the viewport (start).
        - "end start" ->	The bottom of the target element (end) aligns with the top of the viewport (start).

        - ["start end", "end end"] -> Starts when the top of the element reaches the bottom of the viewport and ends when the bottom of the element reaches the bottom of the viewport.
        - ["center center", "center start"] -> Starts when the element‚Äôs center aligns with the viewport‚Äôs center and ends when its center reaches the top.
        - ["start center", "end center"] -> Starts when the top of the element reaches the center of the viewport and ends when the bottom reaches the center.




useTransform:

    useTransform is a hook in Framer Motion that maps (or converts) one value into another. It is mainly used to create smooth scrolling effects, parallax animations, and progress-based UI changes.

    How Does It Work?
        Think of useTransform as a converter:
            - You take one value (like scrollYProgress ‚Üí how much you've scrolled).
            - You map it to another range (like opacity, scale, rotation, etc.).

    Syntax:
        const newValue = useTransform(inputValue, [inputStart, inputEnd], [outputStart, outputEnd]);

        [inputStart, inputEnd] ‚Üí The range of the input value (e.g., scrollY or scrollYProgress).
        [outputStart, outputEnd] ‚Üí The range of the output value (e.g., opacity, scale, position, color, etc.).

    Example : Scroll Progress to Opacity

            const { scrollYProgress } = useScroll(); // Scroll progress (0 to 1)
            const opacity = useTransform(scrollYProgress, [0, 1], [0, 1]); // Map 0 ‚Üí 1

            <motion.div style={{ opacity }} className="h-screen bg-blue-500 flex justify-center items-center">
            <h1 className="text-white text-3xl">Scroll to See Me Fade In</h1>
            </motion.div>;


**Yes, Redux typically works in client components in Next.js because Redux relies on React's state management, which is primarily designed to run in the browser.

**ReturnType is a utility type in TypeScript that allows you to extract the return type of a function type. It is part of TypeScript's built-in utility types.


*export const useAppDispatch = useDispatch.withTypes<AppDispatch>()
    - withTypes is a TypeScript utility introduced in Redux Toolkit v2 to add type safety to the useDispatch and useSelector hooks.




*** In Next.js (App Router), it is necessary to use named exports (GET, POST, PUT, DELETE, etc.) in a route.ts or route.js file to define API routes. This is because Next.js expects HTTP methods to be explicitly declared as named exports for handling requests.
        - Next.js automatically maps HTTP methods (GET, POST, PUT, DELETE) to these named exports.
        - Without named exports, Next.js won‚Äôt know how to handle different HTTP methods in the route.ts file.
        - Dynamic API routing depends on these method-specific exports.


***The utils folder contains general-purpose utility functions, while the lib folder contains more specialized libraries and helper functions.

*** react component must be rendered as jsx/tsx element inside jsx/tsx file.





***Tailwind does not support dynamically injecting before: inside a template string (e.g., before:${timelineDotOuterColor}).

    ‚úÖ Correct way:
        Define the variable with before: included:

        const timelineDotOuterColor = "before:bg-cyan-400"; 
    Then use it directly:

        <div className={`relative before:w-16 before:h-16 ${timelineDotOuterColor} before:opacity-40 before:rounded-full before:-z-10 before:animate-ping`} />

    ‚ùå Wrong way (won‚Äôt work):
        const timelineDotOuterColor = "bg-cyan-400"; // Missing "before:"

        <div className={`before:${timelineDotOuterColor}`} />  // This fails
        
    üî• Why?
    Tailwind compiles class names at build time, and before: must be part of the static class string. It cannot be injected dynamically.





***** The issue is likely occurring because Next.js tries to pre-render the page at build time, but getPortfolioData is making a network request to http://localhost:3000/api, which won't be available during static generation (SSG).

    Why the Error Happens:
        -> getPortfolioData() is an async function fetching data from http://localhost:3000/api.
        -> During the build process, Next.js tries to pre-render the page.
        -> Since http://localhost:3000/api is a local API, it's unavailable during build time.
        -> The build fails because it cannot fetch data, causing an "Error occurred prerendering page".

    Why Removing getPortfolioData Fixes It:
        -> When getPortfolioData() is removed, there's no external API call during pre-rendering.
        -> The page is rendered without needing async data, so Next.js doesn't fail.

    - Use fetch() or axios inside a server component only if the API is accessible at build time (e.g., an external API or a database).
    - If the API is a Next.js route handler (app/api folder), it only runs in the runtime environment (not at build time).
    - The request will fail during SSG (Static Site Generation) because Next.js tries to fetch the API before the server is running.




*** const newUser = await UserPortfolioData.findOne({ 
    portfolio: { connect: { mail: "development.8427@gmail.com" } } 
});

    -> This query is returning null because it does not correctly match nested fields in MongoDB.
    -> This will only match documents where the entire portfolio.connect object is exactly equal to { mail: "development.8427@gmail.com" }, ignoring other fields like msg1, github, etc.
    -> Instead, use dot notation to query nested fields correctly:
            const newUser = await UserPortfolioData.findOne({
                "portfolio.connect.mail": "development.8427@gmail.com"
            });

------------
import { NextRequest, NextResponse } from 'next/server';

export async function GET(
  req: NextRequest,
  { params }: { params: { email: string } }
) {
  const encodedEmail = params.email;
  const decodedEmail = decodeURIComponent(encodedEmail); // handle %40, etc.

  return NextResponse.json({ email: decodedEmail });
}
params is passed separately from req as the second argument.

You should use decodeURIComponent() to safely decode values like emails.
----------------





What is savePDF?
        - savePDF is a KendoReact helper that takes a DOM element and downloads it as a PDF. It‚Äôs a convenience wrapper around Kendo‚Äôs ‚ÄúDrawing‚Äù + ‚ÄúPDF export‚Äù pipeline. 

How does it work (high-level)?
         - It looks at the live DOM node you pass (your resumeRef.current) and reads its computed CSS.
         - It converts that DOM into a vector drawing scene (shapes + text) using drawDOM.
         - It then exports that scene to a PDF and triggers a download with your options (paper size, margins, filename, etc.). 


In other words, it‚Äôs client-side ‚ÄúDOM ‚Üí PDF,‚Äù not a server HTML-to-PDF engine.


Does it ‚Äúconvert HTML to PDF‚Äù?
        -  Yes‚Äîthe rendered HTML (the DOM) of the element you pass is what gets converted to PDF. It‚Äôs not parsing raw HTML strings; it‚Äôs taking what‚Äôs already on the page and turning it into PDF.



Is the text in the PDF selectable?
        - Generally yes. Normal text nodes become real text in the PDF (so you can select/search).

Exceptions:

        - Things like images, canvas, and inline SVG are exported as images inside the PDF, so those parts won‚Äôt be selectable text.
        - If you use characters outside ASCII, you may need to embed a proper TTF font (e.g., DejaVu Sans) via @font-face so the PDF has glyphs to render as text.


TTF stands for TrueType Font:
        - It‚Äôs a common font file format (files end with .ttf).
        - It stores each character as a scalable shape (so text looks sharp at any size).
        - Works on almost all systems (Windows, macOS, Linux).
        - On the web, you can include a .ttf with @font-face so your page‚Äîand exported PDFs‚Äîuse that exact font.
        - Example: Arial.ttf, DejaVuSans.ttf.


What does savePDF return?

        - savePDF(element, options, callback?) doesn‚Äôt return the PDF data‚Äîit just saves the file. If you need the data (e.g., Base64/Blob to upload), use the lower-level API: drawDOM(...) ‚Üí exportPDF(...), which gives you the data URI before saving.

Does it download the PDF to my computer? 
        - Yes. Calling savePDF(...) triggers the browser to download a PDF file with the name you give it.


**What about images‚Äîdoes it ‚Äúfetch‚Äù them again?
        - It uses the images your page is showing. Often the browser will reuse its cache, but if an image comes from another domain, that server must allow it (CORS). If CORS isn‚Äôt allowed, that image might not appear in the PDF.







Here‚Äôs the simple flow from HTML to PDF (like what savePDF does), in plain words:

1. Pick the area
    You pass a DOM element (e.g., your resume container).

2. Read styles
    The library asks the browser for the element‚Äôs computed CSS (fonts, colors, sizes, margins).

3. Lay it out
    It measures boxes just like the page looks on screen (widths, heights, positions).

4. Turn DOM into a drawing
    It converts what it sees into a vector ‚Äúscene‚Äù: text objects, rectangles, lines, images, SVG (canvas becomes an image).

5. Paginate
    That scene is split into PDF pages (A4/Letter) using your margins and scale. Long content continues on the next page.

6. Embed assets
    - Fonts (TTF/WOFF) are embedded so text stays selectable/searchable.
    - Images are pulled from what the page already loaded (external images may need CORS).
    - Links can be kept as PDF hyperlinks.

7. Make the PDF & download
    It packages the pages into a PDF file and triggers the browser download with your filename.

That‚Äôs it: DOM ‚Üí styles ‚Üí layout ‚Üí vector scene ‚Üí paginate ‚Üí embed ‚Üí PDF download.














USING drawDOM, exportPDF :

import { drawDOM, exportPDF } from "@progress/kendo-drawing";

const getResumePdfBlob = async () => {
  if (!resumeRef.current) return null;

  setDownloaded(true);
  try {
    const element = resumeRef.current as HTMLElement;

    // 1) DOM -> drawing scene (Group)
    const group = await drawDOM(element, {
      paperSize: "A4",
      scale: 0.75,
      margin: { top: "1cm", left: "1cm", right: "1cm", bottom: "1cm" },
    });

    // 2) Scene -> PDF (Data URI string)
    const dataUri = await exportPDF(group, {
      paperSize: "A4",
      margin: { top: "1cm", left: "1cm", right: "1cm", bottom: "1cm" },
    });

    // 3) Data URI -> Blob
    const res = await fetch(dataUri);
    const blob = await res.blob(); // type: application/pdf
    return blob;
  } finally {
    setTimeout(() => setDownloaded(false), 2000);
  }
};


If you also want to download it, add:
const blob = await getResumePdfBlob();
if (blob) {
  const filename = `${resumeData.personalInfo.fullname.replace(/\s+/g, "_")}_Resume.pdf`;
  const url = URL.createObjectURL(blob);
  const a = document.createElement("a");
  a.href = url;
  a.download = filename;
  a.click();
  URL.revokeObjectURL(url);
}







// 1) DOM -> drawing scene (Group)
const group = await drawDOM(element, {
paperSize: "A4",
scale: 0.75,
margin: { top: "1cm", left: "1cm", right: "1cm", bottom: "1cm" },
});


await drawDOM(element, {...})
        - Looks at the actual rendered HTML inside element (your resume section), reads its computed CSS (fonts, sizes, colors, positions), and turns it into an internal drawing scene.

Returns group
        - group is just Kendo‚Äôs object that holds that scene (think: a ‚Äúcanvas‚Äù made of shapes + text). It‚Äôs the input you‚Äôll pass to exportPDF next.

The options mean:
        - paperSize: "A4" ‚Üí Lay everything out for an A4 page.
        - scale: 0.75 ‚Üí Shrink the content to 75% so it fits nicely.
        - margin: { top/left/right/bottom: "1cm" } ‚Üí Keep 1 cm empty border on each side (the printable area is inside these margins).

Important:
        - This does not create or download a PDF yet. It only builds the ‚Äúpicture‚Äù of your DOM as vector/text objects. You then call exportPDF(group, ...) to turn that into an actual PDF file (or data URI/Blob).




// 2) Scene -> PDF (Data URI string)
const dataUri = await exportPDF(group, {
paperSize: "A4",
margin: { top: "1cm", left: "1cm", right: "1cm", bottom: "1cm" },
});



What it does:
        - exportPDF(group, {...}) takes the drawing scene you built with drawDOM and turns it into a real PDF laid out as A4 with 1 cm margins.

What you get back:
        - It returns a Data URI string (something like "data:application/pdf;base64,JVBERi0xLjcK...").
        - This is the whole PDF file, just encoded as text.

What it does not do:
        - It doesn‚Äôt download anything by itself. It only gives you the string.

Why this is useful:
    With that dataUri, you can:
        - Make a Blob (to upload or preview):

                    // 3) Data URI -> Blob
                    const res = await fetch(dataUri);
                    const blob = await res.blob(); // type: application/pdf
                    return blob;

                    what fetch(dataUri) does:

                            - dataUri is a special URL that already contains the file data inside the string, e.g.
                            data:application/pdf;base64,JVBERi0xL...

                            - When you call fetch(dataUri):
                                    - The browser sees the URL starts with data: (not http).
                                    - It does not go to the internet. Instead, it parses the string locally.
                                    - If it‚Äôs base64, it decodes that text back into the original bytes.
                                    - It hands you a Response object as if a download succeeded.
                                    - You can then do res.blob() / res.arrayBuffer() / res.text() to get the actual data.

                            - Body of the response contains the actual file data (from the data URI), which you can read with:
                                    - await res.blob() ‚Üí a Blob (great for files like PDFs/images)
                                    - await res.arrayBuffer() ‚Üí raw bytes
                                    - await res.text() ‚Üí text
                                    - await res.json() ‚Üí if it‚Äôs JSON text

                    Think of it like this: fetch(dataUri) tells the browser, ‚Äúopen this file that‚Äôs already baked into the string,‚Äù then gives you a normal Response wrapper so you can easily turn it into a Blob (or whatever you need). No network, all local.

                    overview : 
                        - fetch(dataUri) asks the browser to read that string like a file and gives you a Response object (no network call‚Äîit's all local).
                        - res.blob() converts the response into a Blob (binary data).
                        - Now blob is a real PDF file object (type: "application/pdf") you can upload, preview, or download.

        - Download it yourself:

                    const filename = `${resumeData.personalInfo.fullname.replace(/\s+/g, "_")}_Resume.pdf`;
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement("a");
                    a.href = url;
                    a.download = filename;
                    a.click();
                    URL.revokeObjectURL(url);


                    - Blob = the data itself (a file-like object in memory). Think: ‚Äúhere are the bytes of my PDF/image, with a MIME type.‚Äù
                    - URL.createObjectURL(blob) = a temporary URL string (like blob:...) that points to that Blob so the browser/DOM can use it in places that want a URL (<img src>, <a href>, <iframe src>, etc.).
                    - URL.revokeObjectURL(url) ‚Üí frees the memory used by the blob URL (good cleanup).
---------------










jszip :

type NamedBlob = { blob: Blob; filename: string }; // e.g. "Anish_Singh_Chandel_Resume.pdf"

async function zipAndDownloadResumes(files: NamedBlob[]) {
  const zip = new JSZip();
  const folder = zip.folder("resumes"); // put all PDFs inside a folder in the zip

  files.forEach(({ blob, filename }) => {
    const safeName = filename.endsWith(".pdf") ? filename : `${filename}.pdf`;
    folder!.file(safeName, blob); // add each PDF blob with its name
  });

  // make the .zip as a Blob
  const zipBlob = await zip.generateAsync({
    type: "blob",
    compression: "DEFLATE",
    compressionOptions: { level: 6 }, // 1 (fast) .. 9 (smaller)
  });

  // download the .zip (no extra lib needed)
  const url = URL.createObjectURL(zipBlob);
  const a = document.createElement("a");
  a.href = url;
  a.download = "resumes.zip";
  a.click();
  URL.revokeObjectURL(url);

  // If you use file-saver, you can do:
  // saveAs(zipBlob, "resumes.zip");
}





// suppose you already have one or more resume blobs:
const blob1 = await getResumePdfBlob(); // from your drawDOM/exportPDF flow
const blob2 = await getResumePdfBlob(); // another one...

await zipAndDownloadResumes([
  { blob: blob1, filename: "Anish_Singh_Chandel_Resume.pdf" },
  { blob: blob2, filename: "Jane_Doe_Resume.pdf" },
]);







const zip = new JSZip(); --> Make a new empty ZIP file in memory.

const folder = zip.folder("resumes"); --> Create a folder named ‚Äúresumes‚Äù inside that ZIP (like a directory).

files.forEach(({ blob, filename }) => {
  const safeName = filename.endsWith(".pdf") ? filename : `${filename}.pdf`;
  folder!.file(safeName, blob); // add each PDF blob with its name
});

        - Go through each item in files (each has a PDF Blob and a name).
        - If the name doesn‚Äôt end with .pdf, add .pdf to it ‚Üí safeName.
        - Put the Blob into the ‚Äúresumes‚Äù folder with that file name.


Tiny notes:
    - blob = the actual PDF data.
    - folder! = TypeScript ‚ÄúI promise this isn‚Äôt null.‚Äù
    - This code just builds the ZIP in memory; you‚Äôll still need to call zip.generateAsync({ type: 'blob' }) and then download it (with FileSaver.saveAs or a manual <a> click) to save it to disk.








const zipBlob = await zip.generateAsync({
  type: "blob",
  compression: "DEFLATE",
  compressionOptions: { level: 6 },
});


- zip.generateAsync(...): takes everything you added to the JSZip object and builds the final .zip file.
- await: it‚Äôs done asynchronously (in the background); when it finishes, you get the result.
- type: "blob": ask for the result as a Blob (a file-like object in memory) so you can download or upload it.
- compression: "DEFLATE": use standard ZIP compression.

                    DEFLATE is a lossless compression method used in ZIP files, gzip, and PNGs.
                        - It shrinks data without losing any information.
                        - Works by combining two ideas:
                                - LZ77: finds repeated patterns and replaces them with short references.
                                - Huffman coding: uses shorter codes for frequent bytes and longer codes for rare ones.
                        - Result: smaller files that can be perfectly restored to the original.

- compressionOptions: { level: 6 }: choose compression strength 1‚Äì9

    1 = fastest, bigger file
    9 = slowest, smallest file
    6 = a good middle ground

The result, zipBlob, is your ready-to-save ZIP file in memory.
Example to download:

import { saveAs } from "file-saver";
saveAs(zipBlob, "resumes.zip");






new JSZip() ‚Üí makes an in-memory ZIP container (nothing on disk yet).
zip.folder("resumes") ‚Üí creates an in-memory folder entry inside that ZIP (it‚Äôs just path metadata like resumes/‚Ä¶, not a real folder on your computer).
folder.file(name, blob) ‚Üí adds your PDF blobs into that in-memory ZIP structure.

Nothing is written to disk during the above steps.

When you call: const zipBlob = await zip.generateAsync({ type: "blob", compression: "DEFLATE", ... });

JSZip compresses everything and produces a single Blob in memory that represents the final .zip file. Still not on disk.

It only touches the user‚Äôs disk when you trigger a download, e.g. with:

        saveAs(zipBlob, "resumes.zip");
        // or createObjectURL + <a>.click()


Tiny notes:

    - The ‚Äúfolder‚Äù is virtual (just part of each file‚Äôs path in the ZIP). ZIPs don‚Äôt store ‚Äúreal folders‚Äù‚Äîthey store file paths; unzip tools create the folder from that path when extracting.
    - Memory usage grows with your input files and the produced ZIP. For very large sets, keep an eye on memory.

    - Some unzip apps create a new folder named after the ZIP file when extracting to avoid clutter. That‚Äôs just the extraction target, not a folder inside your ZIP. The internal structure comes only from the paths you set (like resumes/...).






What is saveAs?

    - saveAs is a tiny helper from the file-saver library that lets your web app download a file (like a PDF/ZIP/image/text) that you already have in JavaScript as a Blob, File, or even a URL.

How do I use it?

import { saveAs } from "file-saver";

// Example: download a PDF Blob you already created
saveAs(pdfBlob, "Resume.pdf");

// Example: download a ZIP Blob
saveAs(zipBlob, "resumes.zip");

// Example: download a text file you build on the fly
const blob = new Blob(["Hello"], { type: "text/plain;charset=utf-8" });
saveAs(blob, "hello.txt");


You can also pass a URL (needs CORS if it‚Äôs from another domain):  saveAs("https://example.com/file.pdf", "file.pdf");


What does it do under the hood?

For a Blob/File:

    1) Creates a temporary object URL ‚Üí URL.createObjectURL(blob).
    2) Creates a hidden <a> tag with that URL and your filename.
    3) Programmatically clicks the link to trigger the browser‚Äôs download.
    4) Cleans up (revokes the temporary URL).
    5) Uses special fallbacks for tricky browsers (like old IE / iOS Safari).


For a URL: It tries to download it directly; if it‚Äôs cross-origin, the server must allow it (CORS). Otherwise the browser may block or just open it.

What it can / can‚Äôt do

        ‚úÖ Triggers a download with the filename you provide.
        ‚úÖ Works across browsers and handles quirks for you.
        ‚ùå Can‚Äôt choose the download folder (the browser/user decides).
        ‚ùå If it‚Äôs a cross-origin URL without CORS, it might open in a tab or fail.


Quick example with your ZIP: 

        import { saveAs } from "file-saver";

        async function downloadZip(zipBlob: Blob) {
        saveAs(zipBlob, "resumes.zip"); // that‚Äôs it!
        }


That‚Äôs all: give saveAs your data and a name ‚Üí it triggers a download in the user‚Äôs browser.
